## 测试工程师笔试

是将数字转换成 读法

## 面试

多线程，生产者消费者模型

1.多线程

- 线程:是进程的子任务，是cpu进行调度和分派的基本单位，实现进程内部的并发

多线程之间共享同一个进程的地址空间

线程间通信简单，同步复杂，线程创建销毁，切换简单，速度快，占用内存少

适合多核式分布系统

2.生产者消费者模型


是多线程并发中的一个经典问题

一个模块生产数据，一个模块负责处理

主要就是建立缓冲区 


tcp三次握手，四次挥手，为什么？



url到界面生成的过程

1.浏览器分析连接指向的url
2.浏览器向DNS请求解析url的IP地址
3.浏览器和服务器建立tcp连接(三次握手)
4.浏览器翻出命令，http 请求
5.服务器给出响应，把http响应报文发送给浏览器
6.tcp四次挥手断开连接
7.浏览器解析报文，显示文本


不用第三个变量交换两个变量

1.使用加减法

a=a+b;
b=a-b;
a=a-b;
2.
使用异或来实现


简单介绍测试流程(单元测试到验收测试)

**软件测试**:

1.软件测试的对象

软件需求，概要设计，详细设计，软件运行环境，可运行程序和软件源代码


2.软件测试包括 质量、人员、资源、技术和流程五大要素


3.软件测试四个阶段:

单元测试，集成测试，系统测试，验收测试

- 单元测试

单元测试是对软件中的最小可验证单元进行检查和验证。比如对Java中的类和方法的测试

测试原则:

1.尽可能的保证测试用例相互独立 （测试用例中不能直接调用其他类的方法，而应在测试用例中重写模拟方法）

2.此阶段一般由软件的开发人员来实施，用以检验所开发的代码功能符合自己的设计要求


单元测试的好处：

1、尽早的发现缺陷； 
2、利于重构； 
3、简化集成； 
4、文档； 
5、用于设计


单元测试的不足： 

1、不可能覆盖所有的执行路径，所以不可能保证捕捉到所有路径的错误； 
2、每行代码需要3~5行代码进行单元测试，存在投入与产出的平衡


- 集成测试

集成测试在单元测试的基础上，把软件单元按照软件**概要设计**规格说明的规格要求，组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求。

集成测试包括BigBang、自顶向下、自底向上、核心系统集成、高频集成

- 系统测试

将经过集成测试的软件，作为计算机系统的一部分，与系统中其他部分结合起来，在实际运行环境下进行一系列严格有效的测试，以发现软件潜在的问题，保证系统的正常运行

集成测试和系统测试之间的比较： 
1、测试内容：集成测试是测试各个单元模块之间的接口，系统测试是测试整个系统的功能和性能； 
2、测试角度：集成测试偏重于技术的角度进行测试，系统测试是偏重于业务的角度进行测试。

- 验收测试

也称交付测试

是针对用户需求、业务流程进行的正式的测试，以确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统。

验收测试包括alpha测试和beta测试，alpha测试是由开发者进行的软件测试，beta测试是由用户在脱离开发环境下进行的软件测试


linux 指令

tcp 和udp的区别


画出项目的流程图


手撕代码，单例模式


对测试的理解

1.测试的目的:

尽可能多的发现缺陷，比如功能的错误，性能低下，易用性差

2.测试思路

先假设程序存在什么缺陷，然后执行程序来发现缺陷

3.测试类型

白盒测试：

看得见的程序内部结构，测试源程序的逻辑结构和实现细节。白盒测试必须由开发人员独立执行，因为测试人员无法理解代码内部逻辑

要对所有代码进行单步跟踪测试，关注的是程序的内部细节

黑盒测试：

看不见的程序内部结构，按照规格来测试程序是否符合要求。黑盒测试必须由独立测试小组执行，因为开发人员难以做到客观公正

只需测试模块的接口是否要求，关注的是程序的外部实现

黑盒测试主要设计方法：边界值分析法，等价类划分法、因果图法，错误推测法、流程分析法等

白盒测试的主要设计方法:代码检测法，逻辑覆盖法，基本路径测试法，静态结构分析法等

4.测试内容：

- 1、功能测试：检查软件的功能是否符合要求。
            枚举方法：构造合理的输入，看是否有期望的输出。边界值方法：采用定义域的边界值进行测试。

- 2、容错性测试：检查软件在异常情况下的反应，容错性好的软件会确保系统不发生难以预料的崩溃。
               方法：构造一些不合理的数据看系统的反应（错误的数据类型或定义域外的值）。

- 3、性能与效率测试：测试软件的速度与对资源的利用率。
                  极限测试：持续不停地给服务器发送请求看是否会死掉，给程序输入特别大的数据看是否能吃得消。获取测试的绝对值（如数据的传输率）：记录运行环境对软件的影响。获取测试的相对值（如该软件和其他软件相比快多少倍）：确保被测试的几个软件具有相同的软件和硬件环境中。

- 4、易用性测试：用户不用看用户手册，即具有好的易用性。

- 5、文档测试：检查文档的正确性，完备性，可理解性。
 



## 二面准备

[软件测试流程](https://blog.csdn.net/henni_719/article/details/79847217)

- 时间复杂度和空间复杂度

时间频度:一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。
**并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多**

时间复杂度:在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。

空间复杂度:
一个算法的空间复杂度(Space Complexity)S(n)定义为该算法所耗费的存储空间，它也是问题规模n的函数。渐近空间复杂度也常常简称为空间复杂度。 
空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。

- **C++多态**

c++多态:调用成员函数时，会根据调用函数对象的类型来执行不同的函数

虚函数:是在基类中使用关键字virtual声明的函数。在派生类中**重新定义基类中定义的虚函数**时，
会告诉编译器不要静态链接到该函数。
我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定

纯虚函数:想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。


- **深拷贝&浅拷贝**

如果类中没有显示定义一个拷贝构造函数，会调用编译器自动生成一个拷贝构造函数，该构造函数完成对象之间的位拷贝(潜拷贝)

在某些情况下，类内成员变量需要动态开辟堆内存，如果实现位拷贝，也就是是将对象里的只赋值给另外一个对象
如果成员变量指针已经申请内存，新的对象的成员变量也指向这块内存，这就出现问题，当老的成员变量将内存释放(析构)
这个新赋值的指针就成为了野指针，出现运行错误

潜拷贝会把指针变量的地址复制，没有资源的重新分配，两个指针指向同一个地址资源
深拷贝会重新开辟内存空间，资源重新进行分配

- **哈希表**

哈希表(散列表): 根据关键码值来进行访问的数据结构，通过将关键码值映射到表中的一个位置来访问记录，加快查找的速度

哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，
然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。

碰撞处理
处理两个或者多个键值都会散列到相同索引值的情况:

拉链法  - 使用链表

线性探测法- 开放地址散列表，利用空位来解决冲突


- new的过程

获得一块内存空间、调用构造函数、返回正确的指针

operator new 标准库函数分配新内存
placement new 调用构造函数(简单类型，此步骤忽略)，并传入初始值
返回内存指针(指向该对象的指针)

- delete

析构函数
执行operator delete 标准库函数

new和malloc的比较：

new失败时会调用new_handler处理函数,malloc不会,失败时返回NULL
new能通过placement new自动调用对象的构造函数，malloc不会
new出来的东西是带类型的，malloc是void*，需要强制转换
new是C++运算符，malloc是C标准库函数


