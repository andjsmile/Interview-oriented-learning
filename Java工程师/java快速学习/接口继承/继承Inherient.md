## 继承 Inheritance




### 多态 polymorphism

**操作符多态**

+ 可以作为算数运算，也可以作为字符串连接

**类多态**

- 父类引用指向子类对象
- 调用的方法有重写



### 隐藏

方法的重写是子类覆盖父类的对象方法

隐藏 就是子类覆盖父类的类方法

注意类方法的隐藏

如果调用请尽量使用类名来进行实现


**实例化子类，父类的构造函数一定会被调用**


关键字**super**

- 显式调用父类带参构造方法
- 调用父类属性
- 调用父类方法


作为子类无论如何都会调用父类的构造方法,
默认情况下调用父类的无参的构造方法,

**父类没有无参构造方法的时候(提供有参构造方法，并且不限时提供无参构造方法)**子类会抛出异常。子类尝试调用父类的无参构造方法

必须使用super去调用父类声明的、存在的、有参的构造方法




### Object类

class Object is the root of the class hierarchy

它是所有类的父类

默认继承 extends Object


toString() 返回当前对象的字符串表达

finalize() 一个对象没有任何引用，满足垃圾回收条件，JVM调用方法进行回收

equals() 判读对象的内容是否相等

== 用来判断两个引用是否指向了同一个对象

hashCode()  返回一个对象的哈希值


### final

- final修饰类，表示类不能被继承
- final修饰方法，表示在其子类中不能被重写
- final修饰基本类型变量，该变量只有一次赋值机会

- final修饰引用，表示引用只有一次指向对象的机会


### abstract

抽象方法:声明一个方法，没有实现体，是一个空方法

一个类中有抽象方法，该类必须被声明为抽象类


抽象类可以没有抽象方法，抽象类无法进行实例化


### 抽象类和接口的区别

- 1.子类只能继承一个抽象类，子类可以实现多个接口

- 2.抽象类可以定义 public，protected,package,private  静态及非静态属性，final和非final属性

  接口声明的属性只能是  public，静态，final的

默认是  public static final




### 内部类  inner class

- 静态内部类

- 非静态内部类

- 匿名类

- 本地类



**类、抽象类、接口（接口只是个类型）——简化概括**

类继承--->子类完全继承父类特点
抽象类继承--->继承时抽象的部分不同的子类可以有不同的实现
接口继承--->所有成员在子类都可以有不同的实现

至于为什么要用接口而不是抽象类
这要看二者适用的情况

当个性大于共性时,适合接口,如鸟和飞机,适合抽象出一个飞的接口
当共性大于个性时,适合抽象类,如老鹰和麻雀,适合抽象出一个鸟的父类
另外接口可以实现多重继承,这也是一个特点


容易混淆的误区——实现抽象方法与重写普通方法 的本质

抽象方法与重写的目的都是为了实现多态，

相同点：两者方法体和参数都必须和父类保持一致，
不同点：抽象类没有方法体，重写有， 抽象类比重写更加灵活。

只不过抽象方法在父类中不需要写方法体，并且子类中必须重写该抽象方法。
所以说抽象方法其实就是重写的一种罢了。
抽象类的实现和正常类的重写没区别


**接口的应用场景——继承、实现的选择**

1.因为接口的属性和抽象方法默认是必须公开的（public）
所以如果有需要保护private(私有)的属性或者方法时，必须用继承一个类（抽象类也是类）

2.继承类(一般私有)只能继承一个（单继承），实现接口(公共)可以实现多个（多继承）
所以能用接口解决的问题，基本不用继承一个类(或抽象类)来解决

3.接口之所以提供默认方法，只是为了不用实现，直接可以用（提供方便而已，不要多想）

4.之所以会有抽象类这种类，只是为了在继承私有属性和方法的同时，子类约定好必须使用这个方法。因为继承的普通方法可以不用写出来，而抽象方法必须写出来（只是为了提醒程序员其中重点特殊的功能是什么）
所以如果需要继承父类私有属性的同时，又需要公共的特殊功能时，可以考虑抽象类

5.抽象类是对对象进行的抽象,而接口是一种行为规范

6.二者的选择
(1)优先选用接口，尽量少用抽象类
(2)需要定义子类的行为，又要为子类提供共性功能时才选择抽象类


