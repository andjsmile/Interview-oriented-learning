## 容器



### 类集Collection(interface)

--->表示implemnet实现接口
->  表示继承

#### Set(interface)


**1.TreeSet(TreeSet--->SortedSet->Set->Collection)**

基于红黑树实现，支持有序操作(实现范围查找) 查找效率O(logN)


**2.HashSet(HashSet--->Set->Collection)**

基于哈希表实现，支持快速查找O(1),不支持有序性操作

**3.LinkedHashSet(LinkedHashSet--->Set->Collection)**

具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序



#### List(interface)


**1.ArrayList(ArrayList--->List->Collection)**

基于动态数组实现，支持随机访问

**2.Vector(Vector--->List->Collection)**

类似于ArrayList,但是其保证线程安全

**3.LinkedList(LinkedList--->List->Collection)**

基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此， LinkedList 还可以用作栈、队列和双向队列


#### Queue(interface)

**1.LinkedList(LinkedList--->Queue->Collection)**

可用来使用队列

**2.PriorityQueue(PriorityQueue--->Queue->Collection)**

基于堆结构实现，用来实现优先队列



### Map(interface)


#### SoretedMap(interface)

**1.TreeMap(TreeMap--->SortedMap->Map)**

基于红黑树实现

**2.HashMap(HashMap--->Map)**
基于哈希表实现

**3.HashTable(HashTable--->Map)**

基于哈希表实现，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并 且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安 全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。

**LinkedHashMap(LinkedHashMap--->Map)**

使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。



