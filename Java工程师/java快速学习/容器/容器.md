## 容器



### 类集Collection(interface)

--->表示implemnet实现接口
->  表示继承

#### Set(interface)


**1.TreeSet(TreeSet--->SortedSet->Set->Collection)**

基于红黑树实现，支持有序操作(实现范围查找) 查找效率O(logN)


**2.HashSet(HashSet--->Set->Collection)**

基于哈希表实现，支持快速查找O(1),不支持有序性操作

**3.LinkedHashSet(LinkedHashSet--->Set->Collection)**

具有HashSet的查找效率，内部使用双向链表维护元素的插入顺序



#### List(interface)


**1.ArrayList(ArrayList--->List->Collection)**

基于动态数组实现，支持随机访问

**2.Vector(Vector--->List->Collection)**

类似于ArrayList,但是其保证线程安全

**3.LinkedList(LinkedList--->List->Collection)**

基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此， LinkedList 还可以用作栈、队列和双向队列


#### Queue(interface)

**1.LinkedList(LinkedList--->Queue->Collection)**

可用来使用队列

**2.PriorityQueue(PriorityQueue--->Queue->Collection)**

基于堆结构实现，用来实现优先队列



### Map(interface)


#### SoretedMap(interface)

**1.TreeMap(TreeMap--->SortedMap->Map)**

基于红黑树实现

**2.HashMap(HashMap--->Map)**
基于哈希表实现

**3.HashTable(HashTable--->Map)**

基于哈希表实现，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并 且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安 全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。

**LinkedHashMap(LinkedHashMap--->Map)**

使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。




### ArrayList

基于数组实现

### Vector

基于数组实现，synchronied实现同步
开销大，扩容是2倍扩容


### LinkedList

基于双向链表实现


### HashMap

默认大小是1<<4  16

使用拉链法(头插法)

- 1.计算键值对应的桶
- 2.链表上顺序查找


一个桶存储的链表长度大于 8 时会将链表转换为红黑树。

### HashSet

集合中元素不能重复

没有顺序

HashSet 自身没有独立实现，里面封装了一个Map

HashSet 是作为Map的key而存在的


### Hashtable
实现map接口，键值对保存数据

HashMap   可以存放 null(键和值都可以是 null)
Hashtable 不能存放 null

HashMap   不是线程安全的
Hashtable  是线程安全的


###  HashSet，LinkedHashSet，TreeSet

HashSet:无序
LinkedHashSet  按照插入的顺序
TreeSet 从小到大排序

