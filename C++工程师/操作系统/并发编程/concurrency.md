# 并发编程

### 定义:

如果逻辑流在时间上重叠，那么它们就是并发的(concurrent).这种现象叫做并发concurrency

并发是一种操作系统内核用来运行多个应用程序的机制。

并发不仅仅局限于内核，也可以在应用程序中使用

**应用级并发**

1.访问慢速I/O设备
2.与人交互
3.通过推迟工作降低延迟
4.服务多个网络客户端  - 并发服务器
5.多核机器上进行并行计算


### 并发程序 concurrent program 

应用级并发的应用程序称为并发程序


#### 1.进程
基于进程的并发，每个逻辑控制流都是一个进程，内核进行调度和维护，控制流必须使用进程间通信机制IPC进行通信

#### 2.I/O多路复用

应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。所有的流都共享同一个地址空间

#### 3.线程

线程是运行在一个单一进程上下文中的逻辑流，像进程一样有内核调度，像I/O多路复用一样共享同一个虚拟地址空间

### 基于进程的并发服务器

- 服务器会运行较长时间，回收僵死zombie子进程的资源 SIGCHLD
- 父子进程必须关闭它们各自的connfd副本.父进程必须关闭已连接描述符,避免内存泄漏
- 套接字的文件表表项中的引用计数，直到父子进程的connfd都关闭流，客户端的连接才会终止


**优劣:**

父子进程共享状态信息，共享文件表，但不共享用户地址空间

进程共享状态信息困难，使用IPC进程间通信机制，比较慢，IPC开销很高。


### 基于I/O 多路复用的并发编程

服务器响应两个互相独立的I/O事件

- 1.网络客户端发起连接请求
- 2.用户的键盘输入命令行

I/O多路复用使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序

函数处理类型fd_set的集合，也叫描述符集合

描述符集合可以看作是一个n的位向量

Bn-1,...B1,B0;

只有Bk=1的时候，描述符k才表名是描述符集合的一个元素

select 函数会一直阻塞，直到读集合中至少有一个描述符准备好可以读。

事件驱动设计的优点，它比基于进程的设计给了程序员更多的对程序行为的控制

并发粒度减小，复杂性还会上升

粒度是指每个逻辑流每个时间片执行的指令数量



### 基于线程的并发编程

线程就是运行在进程上下文中的逻辑流

线程由内核调度,线程有自己的线程上下文 thread context

线程上下文:
- 整数线程 TID
- 栈
- 栈指针
- 程序计数器
- 通用目的寄存器值
- 条件码

多个线程运行在单一进程的上下文中，共享这个进程虚拟地址空间的所有内容

- 代码
- 数据
- 堆
- 共享库
- 打开的文件


**线程终止:**
1.线程可以从例程函数中返回，隐式终止
2.pthread_exit显式终止，主线程调用，会等待其他对等线程终止，再终止主线程和整个进程
3.exit函数，函数终止进程及进程相关的所有线程
4.pthread_cancel() 终止当前线程

线程的终止及回收

pthread_join()
线程调用函数，等待其他线程终止

默认情况下，线程被创建程可结合的，为了避免内存泄漏，每个可结合线程都应该要被其他线程显式回收

pthread_detach() 分离线程



### 变量映射到内存

**全部变量**

全局变量定义在函数之外的变量，运行时虚拟内存的读写区域只包含每个全局变量的一个实例，任何线程都可以引用

**本地自动变量**

本地自动变量就是定义在函数内部，但是没有static属性的变量

**本地静态变量**

本地静态变量是定义在函数内部并有staitc属性的变量。和全局变量一样，虚拟内存的读写区域只包含在程序声明的每个本地静态变量的一个实例



### 信号量 semaphore

