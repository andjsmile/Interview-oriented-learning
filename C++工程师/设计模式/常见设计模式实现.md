# 设计模式

[参考](https://www.runoob.com/design-pattern/singleton-pattern.html)

## 1.常见的设计模式

**单例模式**

单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

单例模式有三个要素: 
- 一是某个类只能有一个实例;
- 二是它必须自行创建这个实例;
- 三是它必须自行向整个系统提供这个实例。


```java
// 创建一个singleObject类

public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}

// 从类中获取唯一对象

public class SingletonPatternDemo {
   public static void main(String[] args) {
 
      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();
 
      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();
 
      //显示消息
      object.showMessage();
   }
}
```

面试手撕单例模式代码
```cpp
// 非线程安全
class Singleton
{
public:
   static Singleton* getInstance()//静态方法，获取唯一实例
   {
       static Singleton instance;
       return &instance;
   };
private:
  Singleton(){};//私有的构造方法
  ~Singleton(){};//私有的析构方法

};

// 线程安全

#include <iostream>
#include <pthread>

class singleton{

private:
   singleton();
   singleton(const singleton &);                // 禁止拷贝
   singleton& operator=(const singleton &){};   // 禁止赋值
   
   static singleton *unique_instance;
   static pthread_mutex_t mutex;

public:
   static singleton* getInstance()
   {
      pthread_mutex_lock(&mutex);
      if(unique_instance==nullptr)
      {
         unique_instance=new singleton();
      }
      pthread_mutex_unlock(&mutex);
      return unique_instance;
   }
};
```


单例模式的多线程安全问题

在单例模式的实现中，不采取任何措施，在多线程中是不安全的，因为会同时创建多个实例


单例模式的实现

[参考](https://www.runoob.com/design-pattern/singleton-pattern.html)


```java

// 饿汉式,线程安全
// pros: 没有加锁，线程执行效率高
// cons: 类加载时就初始化，浪费内存
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
// 懒汉式，线程安全
// pros: 第一次调用才初始化，避免浪费内存
// cons: 必须加锁 synchronized 才能保证单例，但加锁会影响效率

public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}

// 双重检验锁(DCL)
// 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}

```


**工厂模式**

工厂模式主要解决接口选择的问题

该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行

- 优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。
- 缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事

```java
// 1.创建接口
public interface Shape {
   void draw();
}

// 2.创建接口的实体类

public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}

public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}

public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}

// 3.创建一个工厂，生成基于给定信息的实体类的对象

public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}

// 4.使用工厂

public class FactoryPatternDemo {
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```



**观察者模式**

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）

比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式

```java
// 1.创建 subject类

import java.util.ArrayList;
import java.util.List;
public class Subject {
   
   private List<Observer> observers 
      = new ArrayList<Observer>();
   private int state;
 
   public int getState() {
      return state;
   }
   public void setState(int state) {
      this.state = state;
      notifyAllObservers();
   }
 
   public void attach(Observer observer){
      observers.add(observer);      
   }
 
   public void notifyAllObservers(){
      for (Observer observer : observers) {
         observer.update();
      }
   }  
}

// 2.创建 observer类
public abstract class Observer {
   protected Subject subject;
   public abstract void update();
}

// 3.创建实体观察者类

public class BinaryObserver extends Observer{
 
   public BinaryObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( "Binary String: " 
      + Integer.toBinaryString( subject.getState() ) ); 
   }
}

public class OctalObserver extends Observer{
 
   public OctalObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
     System.out.println( "Octal String: " 
     + Integer.toOctalString( subject.getState() ) ); 
   }
}

public class HexaObserver extends Observer{
 
   public HexaObserver(Subject subject){
      this.subject = subject;
      this.subject.attach(this);
   }
 
   @Override
   public void update() {
      System.out.println( "Hex String: " 
      + Integer.toHexString( subject.getState() ).toUpperCase() ); 
   }
}

// 4.使用实体和观察者对象

public class ObserverPatternDemo {
   public static void main(String[] args) {
      Subject subject = new Subject();
 
      new HexaObserver(subject);
      new OctalObserver(subject);
      new BinaryObserver(subject);
 
      System.out.println("First state change: 15");   
      subject.setState(15);
      System.out.println("Second state change: 10");  
      subject.setState(10);
   }
}

/*
输出结果
First state change: 15
Hex String: F
Octal String: 17
Binary String: 1111
Second state change: 10
Hex String: A
Octal String: 12
Binary String: 1010
*/
```