## TCP相关的常见面试问题

**1.TCP和UDP的区别**

transmission control protocol

user datagram protocol

- tcp是面向连接的，udp无连接

tcp在传输前要建立连接，数据传输后要释放连接

- tcp提供可靠的全双工通信，udp尽自己最大的努力通信，不保证可靠

- tcp占用的资源对，udp占用的资源少

- 运输协议数据单元不同，tcp是tcp报文段，udp是用户数据段

- tcp是面向字节流的，udp是面向报文的

- tcp具有拥塞控制，udp没有拥塞控制

- tcp不提供广播和多播服务，udp支持一对一，一对多，多对一的交互通信


**2.TCP如何保持可靠传输**


- 校验和，tcp在发送报文前，发送方要计算校验和，收到数据后，接收方也要计算校验和，不想等直接放弃

- 序列号和确认应答，tcp将每个字节进行编号，接收到对方数据，进行确认应答，发送ACK报文

- 超时重传，没有等到ack报文，启动超时重传机制

- **连接管理**，三次握手和四次挥手

- 流量控制，避免丢包和数据拥塞

- 拥塞控制，防止过多的数据注入到网络中

**3.TCP三次握手，为什么采用三次握手，两次可以吗**

A->B 发送数据

1.A主动打开，B被动的打开连接，B进入接听状态。A打算建立TCP连接
  先向B发送连接请求报文段，其中同步位 SYN=1,序列号 seq=x
  这个报文段不能携带数据，但是要消耗一个序号
  A进入已发送状态

2.B收到请求报文，如果同意建立连接，向A发送ACK确认报文
  同步位 SYN=1,确认号 ACK=1，初始序列号 seq=y，确认号 ack=x+1
  这个ACK报文段也不能携带数据，消耗一个序号
  B进入同步收到状态

3.A收到B的确认报文后，还要给B发送确认报文，ACK=1,seq=x+1(上一个报文的ack)
  ack=y+1(上一个报文的seq+1，因为消耗一个序号)
  这个ACK报文可以携带数据


两次握手不可以，一定需要最后一次确认

**失效的连接请求**

A发送一个请求，丢失了，于是A再发送一个连接请求，重新建立连接，发送数据并释放连接

A丢失的连接请求滞留在网络中，传输数据后，这个请求又发送到B，B错误的以为A还要发送数据，因此发送确认报文，但是A
没有运输需求，如果没有最后一次确认，B会一直等待A的确认

采用三次报文，如果B没有收到A的确认，可以知道A没有建立连接的需求，可以避免上述情况


**4.TCP四次挥手，为什么又最后的timewait，等待时长是多少**

1.A和B都处于已建立的连接状态，A应用进程向其TCP发送出连接释放报文段，并停止发送数据，主动关闭TCP连接
  FIN=1，seq=u,u等于前面已发送的最后一个字节的序号加1
  A进入FIN-WAIT-1 终止等待1，等待B的确认

2.B收到释放连接后连接后，立即发出确认，
  ACK=1,确认号 ack=u+1,序列号 seq=v， v等与前面所有已传送数据的最后一个字节的序号加1
  B进入CLOSE-WAIT关闭等待状态
  TCP服务进程向B的高层应用进程告知，此时A到B的连接已经释放。
  TCP处于半关闭状态，B->A的方向的连接尚未关闭

3.A收到B的确认后，进入到FIN-WAIT2状态，终止等待2，等待B发送连接释放报文段

4.若B没有数据可以发送，则应用进程通知TCP释放连接
  FIN=1,ACK=1,seq=w，ack=u+1
  B进入LAST-ACK 最后确认的状态，等待A的确认

5.A收到B最后的确认，必须对此发送确认报文
  ACK=1,seq=u+1,ack=w+1 
  进入TIME-WAIT 时间等待状态

6.此时TCP连接没有完全释放，必须经过时间等待计时器设置的2MSL之后，A才进入CLOSED状态
  MSL叫做最大报文段寿命


为什么要等待2MSL的时间？

- 保证A最后发送的ACK报文段能够达到B，因为这个报文可能会丢失，B会重传一个确认报文段
  A再重新发送确认报文，并且重启计时器，直到A,B正常进入到CLOSED状态


- 防止已经失效的请求报文

- B要先比A进入CLOSED状态


为什么挥手是四次而不是三次?

tcp是全双工的，它允许两个方向的数据传输被独立关闭，当主动发送关闭的一方关闭连接之后，tcp进入半关闭状态

被动关闭方，对"对主动关闭报文的确认"和"关闭连接" 是两次操作进行的

对主动关闭的报文的确认是为了快速告诉主动关闭方，此主动关闭报文已经收到，
此时被动方不立即关闭连接是为了将缓冲中剩下的数据
从输出流发送会主动方（主动方接受数据后同样要进行确认）



确认关闭和关闭连接分两次进行。


**5.TCP怎么进行拥塞控制**

慢启动，拥塞控制，快重传，快恢复

判断网络拥塞出现:当网络出现超时的情况

1.慢启动:一开始设置一个比较小的拥塞控制窗口cwnd，进行数据传输，收到一个报文段的确认，将cwnd+1，
        cwnd是2^n的倍数增长，慢启动不是增长速度慢，只是增长的初始基数小

2.拥塞避免:慢启动的算法增长的速度比较快，当 cwnd=ssthresh(预先设置好的门限值)，我们启动拥塞避免算法
          窗口值开始线性增长

  随着拥塞算法的进行，网络出现超时情况，这判断为拥塞出现，这个时候将cwnd设置为一开始的值
  重新进行慢开始-拥塞避免的过程，并且将此时的门限值设为出现拥塞时的cwnd的一半。  ssthresh

3.快重传:快重传的目的是为了让发送方尽早知道某个报文的丢失，
        **当我们重复收到某一个报文段的3次确认，我们就可以判断，他的下一个报文段可能出现丢失**，但是并不是网络拥塞出现
        启动快重传算法，立即重传丢失的报文段

4.快恢复:上面快重传算法的启动只是因为个别报文段的丢失，我们这个时候并不判断为网络拥塞，而是启动快速恢复算法
        将cwnd= ssthreh= 当前cwnd的一半，并且开始拥塞避免算法




**6.tcp和udp对应的应用层有哪些协议**

1.tcp
 
 电子邮件         SMTP    简单邮件传输协议
 远程终端输入      TELNET 远程终端协议
 万维网           HTTP   超文本传输协议
 文件传递         FTP     文件传输协议


 2.udp

 名字转换          DNS    域名系统
 文件传送          TFTP   简单文本传送协议
 路由选择协议       RIP    路由信息协议
 IP地址配置        DHCP   动态主机配置协议
 网络管理          SNMP   简单网络管理协议
 远程文件服务器     NFS    网络文件系统

 IP电话
 流式多媒体通信

 **7.端口号**


1.服务器熟知端口号:0~1023

 FTP      21
 TELNET   23
 SMTP     25
 DNS      53
 HTTP     80
 HTTPS    443

2.服务器登记端口号 :1024~49151


3.客户端端口号 :41592~65535

只有在客户端进程运行的时候才动态选择，因此也叫短暂端口号
这类端口号留给客户进程暂时使用，通信结束后就释放，不再进行占用


**7.简述DNS域名系统及其工作原理**

DNS:domain name system 域名系统

互联网的命名系统，用来把人们使用的机器名字转换为IP地址

- 主机向本地域名服务器查询时一般使用递归查询

**递归查询**:就是如果本地域名服务器没有所需域名的IP地址，
            本地域名服务器就以客户的方式向其他根域名服务器继续查询，而不是主机自己进行查询

- 本地域名向其他根域名服务器进行查询的时候一般使用迭代查询

**迭代查询**:当某个根服务器收到本地域名服务器的请求报文时，要么告诉它所需域名的IP地址，
            要么告诉它下一步应该向那个服务器发起询问，然后让本地域名服务器自己查询


- 本地域名服务器迭代查询，先向一个根域名服务器查询
  根域名服务器告诉本地服务器，下一步向顶级域名服务器 dns.com查询
  顶级域名服务器告诉本地服务器，下一步查找权限域名服务器  dns.adc.com
  本地域名服务器向权限域名服务器发起查询，权限域名服务器告诉本地域名服务器所需的IP地址
  本地域名服务器再告诉主机


本地域名服务器 - 设置IPv4 ，IPv6设置中填写的DNS
手工指定或者DHCP自动分配的

权限域名服务器- 负责一个区域的域名服务器，不给给出所需的ip地址，返回给客户应该找哪一个权限服务器

顶级域名服务器 - 二级域名 例如 com










