### 各种排序算法和时间复杂度


1.插入排序

对于一个带排序数组来说，其初始有序数组元素个数为 1，然后从第二个元素， 插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位;如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前 元素的下一位中。

2.希尔排序

先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关， 其最后一个值必须为 1.

3.归并排序

该算法采用分治法;对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到 n/2 个长度为2或者1的有序子序列;然后再两两归并，直到得到1个长度为m的有序序列

4.冒泡排序

对于包含 n 个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素， 若为逆序，则交换元素位置;然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前 前 n-i 个元素中的最大的元素移到 n-i 位置。遍历 n 次，完成排序。

4.快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比 另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过 程可以递归进行，以此达到整个数据变成有序序列。

5.选择排序

每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个 元素交换位置，从而使有序数组元素加 1，无序数组元素减 1.初始时无序数组为空

6.堆排序

堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将排序 数据构造一个最大堆(升序)/最小堆(降序)，然后将堆顶元素与待排序数组的最后一个元素 交换位置，此时末尾元素就是最大/最小的值。然后将剩余 n-1 个元素重新构造成最大堆/最小堆。

7.计数排序

如果比元素 x 小的元素个数有 n 个，则元素 x 排序后位置为 n+1

8.桶排序

1)设置一个定量的数组当作空桶子; 2)寻访序列，并且把记录一个一个放到对应的桶子去; 3)对每个不是空的桶子进行排序。 4)从不是空的桶子里把项目再放回原来的序列中

桶排序只是一个概念，算是底层实现

- 计数排序
- 基数排序





### 海量数据如何除去最大的topk

1.内存足够的情况下，直接全部进行排序(快速排序),选取最大的k个元素

2.最小堆法,
  这是一种局部淘汰法
  先读取k个数建立最小堆，将剩余的数字依次与最小堆的堆顶进行比较，小于堆顶的元素，则比较下一个
  否则删除堆顶元素，并将新数据插入堆中，重新调整最小堆，遍历完成所有的数据后，最小堆的数据即为最大的k个数

3.分治法

将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大 的 K 个数。此时剩下 N*K 个数据，如果内存不能容纳 N*K 个数据，则再继续分治处理，分成 M 份，找出每份数据中最大的 K 个数，如果 M*K 个数仍然不能读到内存中，则继续分治处理。直到 剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理

4.hash法+最小堆法

如果数据中的重复数字比较多的话，先通过hash法，把重复的数字去掉，缩小运算空间
处理后如何可以读入内存，可以直接排序，不行就使用最小堆法

#### 快排序的时间复杂度

快排的最差时间复杂度  O(n^2)，元素是倒序的时候复杂度最高

这个时候快速排序退化为冒泡排序


####  稳定排序

定义:
在待排序的序列中，存在具有多个具有相同关键字的记录，经过排序，这些记录相对次序保持不变
r[i]=r[j],且 r[i]在 r[j]前面， 在经过排序后，r[i]仍在r[j]前面。这种排序算法成为稳定排序算法
否则，称为非稳定排序算法

排序方法中为稳定排序的:
冒泡排序，插入排序，归并排序  还有计数排序，基数排序




