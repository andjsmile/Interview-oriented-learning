
## 选择题中的知识点

1.printf函数从右向左编译，从左向右输出，符合栈模型

2.类空间大小，是类成员中内存最大值 的最小整数倍

指向虚函数表的指针为8字节，类中所有虚函数都存在一个虚函数表中，所以只需要一个指针


3.数据库相关
(1) BTree 索引是大多数 MySQL 存储引擎的默认索引类型，不是B+Tree。
(2) 哈希索引是memory引擎表的默认索引类型，memory也支持btree。
(3) 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行（即不能使用哈希索引来做覆盖索引扫描）。
(5) 空间索引不会要求where子句使用索引最左前缀可以全方位索引数据，可以高效使用任何数据组合查找 配合使用mercontains()函数使用。
(6) 索引将随机I/O变为顺序I/O


4.linux 五个查找命令

- find

$ find <指定目录> <指定条件> <指定动作>

　　- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。

　　- <指定条件>： 所要搜索的文件的特征。

　　- <指定动作>： 对搜索结果进行特定的处理

find的使用实例：

　　$ find . -name "my*"

搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。

　　$ find . -name "my*" -ls

搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。

　　$ find . -type f -mmin -10

搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。


- locate

其实是“find -name”的另一种写法

locate命令的使用实例：

　　$ locate /etc/sh

搜索etc目录下所有以sh开头的文件。

　　$ locate ~/m

搜索用户主目录下，所有以m开头的文件。

　　$ locate -i ~/m

搜索用户主目录下，所有以m开头的文件，并且忽略大小写。


- whereis

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息

- which

which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令

- type

type命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令

type命令的使用实例：

　　$ type cd

系统会提示，cd是shell的自带命令（build-in）。

　　$ type grep

系统会提示，grep是一个外部命令，并显示该命令的路径。

　　$ type -p grep

加上-p参数后，就相当于which命令。


4.进程调度

进程三种状态间的转换
一个进程在运行期间，不断地从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。 
A. 就绪—>执行
处于就绪状态的进程，当进程调度程序为之分配好了处理机后，该进程便由就绪状态转换为执行状态；
B. 执行—>就绪 
处于执行状态的进程在其执行过程中，因分配给它的一个**时间片**已经用完而不得不让出处理机，于是进程从执行状态转换为就绪状态；
C. 执行—>阻塞
正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态；
D. 阻塞—>就绪
处于阻塞状态的进程，若其等待的事件已经发生，于是进程便从阻塞状态转变为就绪状态


进程的三种基本状态
进程在运行中不断地改变其运行状态。通常，一个进程必须具有以下三种基本状态：
就绪状态： 
当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态就称为就绪状态；
执行状态：
当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态；
阻塞状态：
正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而进入阻塞状态。引起进程阻塞的事件有很多种，例如，**等待I/O完成、申请缓冲区不能满足、等待信号**等


执行-->就绪：时间片完；
就绪-->执行：被调度；
执行-->阻塞：等待事件，io请求；
阻塞->就绪：io完成


5.换页率

缺页率 = (页面置换次数+分配给该进程的物理块数)/要访问的页面总数


6.http

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。
HTTP 1.1则支持永久连接, 并且默认使用永久连接. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).

http1.1新添加的状态码

100  Continue  初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）  
101  Switching Protocols  服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）  


7.完全二叉树

完全二叉树，叶子结点数n/2向上取整


8.各种算法

- 迪杰斯特拉(Dijkstra)
贪心策略是每次选可达的点中距离源点最近的点进行扩展，即贪心选取最短距离的点
- 库鲁斯卡尔(Kruskal)
贪心策略是每次选最短的边（刨除成环的边）来作为最小生成树，即贪心最短边
- 普里姆算法(Prim)
贪心策略是每次选可达的点中距离曾经扩展过的点中任意点的最短距离，类似Dij，只是不是找距离源点的最短距离
- KMP
贪心策略0.0 不是贪心
是动态规划，动态规划的是当前状态失败之后上一次匹配的位置（求的是最长的与前缀子串匹配的左子串）


用到贪心算法的是：Dijkstra、Prim、 Kruskal 
未用到的是：KMP和FLOYD算法，其中FLOYD采用类似于动态规划的思想


9.哈希算法在信息安全方面

A、文件校验
我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测并纠正数据传输中的信道误码，但却不能防止对数据的恶意破坏。
B、数字签名
Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。
在这种签名协议中，双方必须事先协商好双方都支持的Hash函数和签名算法

C、鉴权协议
有个称为“挑战-认证模式”的鉴权协议：需要鉴权的一方，向将被鉴权的一方发送随机串（“挑战”），被鉴权方将该随机串和自己的鉴权口令字一起进行 Hash 运算后，返还鉴权方，鉴权方将收到的Hash值与在己端用该随机串和对方的鉴权口令字进行 Hash 运算的结果相比较（“认证”），如相同，则可在统计上认为对方拥有该口令字，即通过鉴权


10.快速排序的结果

快速排序的核心思想是基准数就位，每一趟至少有一个基准数就位，所以两趟下来至少就位两个基准数就位

把最终排序写出来，与选项中的对照，有两个及两个以上的数字对应顺序就说明是满足要求的,(对应两次排序)

11.构造函数问题

基类构造函数>子类成员构造函数>子类构造函数

main函数中
A a创建A类的对象，调用A的构造函数，输出A
B b(a)创建B类的对象
B继承A先调用父类A的构造函数，再次输出A
继续调用B本身的构造函数，这里对象a已经存在，无需再构造无输出，但会调用A的拷贝构造函数(隐式拷贝构造函数)
所以b._a是a的拷贝，B本身的构造函数输出B
main函数调用结束返回时，释放顺序与构造顺序相反。
所以先释放变量b，调用子类析构函数 输出~B
析构上面提到的拷贝，也就是b._a，调用A的析构函数~A
然后父类析构函数   ~A
最后对象a调用A的析构函数 ~B
