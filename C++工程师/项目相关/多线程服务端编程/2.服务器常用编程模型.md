1.Reactor模式

non-blokcing IO + IO multiplexing  这种模式的高性能网络库中应用较广

这种模型中，程序的基本结构是一个事件循环(event loop) ，以事件驱动(event-dirven)
和事件回调的方式实现业务逻辑

reactor 模型的
- 优点:
编程不难，效率挺高，可以使用读写socket，连接的建立connect/accept 甚至DNS解析
都可以使用非阻塞的方式进行，提高并发度和吞吐量,对I/O密集的应用是一个不错的选择
- 缺点:
要求事件的回调函数必须是非阻塞的，对于涉及网络IO的请求响应式协议，
容易割裂业务逻辑，使其散布于多个回调函数之中,相对容易理解和维护
**回调函数**
回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应

2.C++网络服务程序的模式

non-blocking IO+one loop per thread

**one loop per thread**
程序里每个IO线程有一个 eventloop(reactor) 用于处理读写和定时事件
```cpp
// 实现任务队列
typedef std::function<void()> Functor;
BlockingQueue<Functor> taskQueue        // 线程安全的阻塞队列

BlockingQueue<T>                        // 实现数据的生产者消费者队列
// 这里的T是数据类型而非函数对象
```


one (event)loop per thread+ threadpool

- event loop 也叫IO loop 用作IO multiplexing 配合non-blockingIO 和定时器
- threadpool 用来做计算，具体可以是任务队列或生产者消费者队列


3.进程间通信只使用TCP

sockets通信pipe通信的异同点

TCP的sockets和pipe都是操作文件描述符，用来收发字节流
都可以进行read/write/fcntl/select/poll

不同点:sockets是支持双向通信的
      pipe是单向的，双向通信来得选择两个文件描述符
      进程要有父子关系才能使用pipe
