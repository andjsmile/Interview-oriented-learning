# 面试被问过的问题

* 介绍一下这个项目(几乎是必问的)
* 定时器是怎么实现的？还有什么实现方式？
* 实现一个无锁队列(用原子操作)
* eventfd是什么？有什么好处？
* 双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？
* 什么是优雅关闭连接？(就是read()到0，要透明的传递这个行为而不是直接暴力close())
* epoll的边沿触发和水平触发有什么区别？(epoll的源码并不长，从源码的角度回答比较好)
* epoll为什么高效，相比select和poll
* HTTP报文都有哪些字段？
* 假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？(其实就是不间断的提供服务，参考nginx的平滑升级)
* 有没有实现内存池？
* 一个请求到来具体的处理过程是怎样的？
* 线程的唤醒还有哪些方式？
* 怎么检查内存泄漏的？
* 用到了哪些智能指针和RAII机制，几种锁的区别是什么
* 任务队列是怎么实现的，除了加锁还有什么方式？
* 如何解决死锁？
* 怎么进行压测的？
* 为什么要用非阻塞io？
* 为什么要做这个项目？
* Reactor模式是什么？


# 自己考虑可能会问的问题

1.线程池 threadpool的实现

2.为什么选择多线程的并发模型

并发模型有多进程，多线程，事件驱动模型(epoll,poll,select)

多进程模型首先进程比较占资源，切换起来比较麻烦，Linux下最大进程也有限制


3.为什么使用epoll

epoll 作为IO多路复用的实现方式

使用epoll可以将任务拆分为独立事件，各个事件可以被独立监视和执行

之所以选择 epoll，因为事件驱动适合IO密集性操作，HTTP服务器的核心就是响应请求数据，涉及大量请求
并发量上来之后，传统的多进程、多线程模型虽然并发量很大，但大多处于阻塞状态，即使多为就绪态，系统调度开销也非常大，因此这里使用事件驱动模型无疑更适合

http服务器的epoll流程

- 首先需要注册到"监听事件"，之后不需要一直等待下去，直接返回。

- 一旦内核监听到请求就会自动通知可以去建立连接并创建连接描述符，该连接描述符被注册到"读事件"，之后立即返回。

- 用户发送的数据到达服务器，内核感知到读事件，建立任务并放入线程池中。之后唤醒等待任务的worker线程来执行响应操作。

4.log日志
Log everything All The Time


