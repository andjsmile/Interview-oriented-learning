# 学习陈硕大神
## 结合自己的C++ high performance web server


1.什么是临界资源和临界区?

- 临界资源

一次只允许一个进程使用的资源，各个进程采用互斥的方式,实现的共享资源叫做临界资源

属于临界资源的硬件有，打印机，磁带机等；软件有消息队列，变量，数组，缓冲区等。诸进程间采取互斥方式，实现对这种资源的共享。


- 临界区

每个进程中访问临界资源的那段代码称为临界区 critical section

每次只允许一个进程进入临界区，进入后，不允许其他进程进入。不论是硬件临界资源还是软件临界资源，多个进程必须互斥的对它进行访问。多个进程涉及到同一个临界资源的的临界区称为相关临界区。使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态，并在一定程度上影响程序的运行性能。


2.shared_ptr的技术与缺陷



3.线程同步的四项原则(重要性依次递减)

-  首要原则,尽量最低限度地共享对象，减少需要同步的场合。
-  使用高级的并发编程构件,taskQueue，Producer-Consumer Queue,countdownLatch
-  在必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量
-  不要自己编写lock-free代码,不要使用内核级的同步原语


4.CountDownLatch

condition variable 是一个非常底层的同步原语，很少直接使用，用来实现高层的同步措施

BlockingQueue<T> ,CountDownLatch

倒计时CountDownLatch是一种常用且易用的同步手段

主要用途:

- 主线程发起多个子线程，等待这些子线程各自都完成一定的任务后，主线程继续执行.
  主线程等待多个子线程完成初始化

- 主线程发起多个子线程，子线程都等待主线程，主线程完成其他的任务后，通知所有子线程开始运行
  通常用于多个子线程等待主线程发出"起跑"命令


mutex和condition variable 这两个底层的同步原语句，主要是用来实现更高级别的 并发编程工具

在多线程中不要大量使用 这个两个来实现同步



5.单例模式
pthread_once 实现单例模式版本见  “C++工程师/操作系统/设计模式/SingletonWithPthread_once.cpp”

函数原型
```cpp
int pthread_once(pthread_once_t *initflag,void (*initfn)(void));
// initflag 必须是一个非本地变量(全局变量或静态变量)，必须初始化为 PTHREAD_ONCE_INIT
// 每个线程都调用pthread_once ，系统保证初始化例程initfn 只被调用一次，
```

6.线程的等待

生产代码中线程的等待可以分为两种:

- 一种是等待资源可用(select/poll/epoll_wait,要么等待条件变量上)
- 一种是等着进入临界区(等待mutex上) ,读写共享数据 ，这种等待时间非常短,否则程序的性能和伸缩性就会有问题


程序的正常执行需要等待一段已知的时间 ,向 事件循环 eventloop 里注册一个timer，然后在timer的回调函数里接着干活
线程是一个珍贵的共享资源，不能轻易浪费(阻塞也是浪费)

等待某个事件发生，应该采用条件变量或者I/O事件回调，不能使用sleep来轮询


7.线程同步的总结

- 线程同步四项原则，尽量用高层同步设施(线程池，队列，倒计时)

- 使用不同的互斥器 mutex 和条件变量完成剩余的同步任务,采用RAII手法和 scoped locking 范围锁


8.使用shared_ptr来实现 copy-on-write

看文件夹 C++工程师/操作系统/CopyOnWrite-shared_ptr.cpp


