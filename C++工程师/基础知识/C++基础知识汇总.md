先努力学习消化！！！
# 2019.07.26

## 每日一章

一天总结 C++primer 一个章节中的知识点

## 第一章知识点的总览(2019.07.26)

**1.编译器可以检查出的错误**

- 语法错误 syntax error
- 类型错误 type error
- 声明错误 declaration error

**2.类**
我们通过定义一个类，来定义自己的数据结构

可以使用类类型

**3.调用运算符 ()**

我们使用curly brace来调用函数



## 第二章.变量和基本类型(2019.07.27)

**1.内置类型**

内置类型分为算术类型+空类型 void

算术类型分为  整型(包括字符和布尔类型)  + 浮点型

对象的类型包含了数据和能参与的运算

bool类型与非bool类型之间的转换
浮点数和整数之间的转换


**2.变量**

初始化和赋值是两个完全不同的操作

变量的初始化-对象创建的时候获得一个特定的值

C++11新特性，列表初始化的重要特点- 列表初始化不进行强制转换，会出现数据丢失的风险

:: 可以显式访问全局变量

**3.变量的声明及定义**

分离式编译 ---- 程序分成多个文件 ---- 需要在文件间共享代码  ----- 声明和定义 分开

声明  - 使得名字为程序所知，规定了变量的类型和名字
定义  - 创建与名字关联的实体，规定变量的类型和名字，申请储存空间，也可能会为变量赋一个初始值

extern  声明 关键字


**4.变量命名规范**
- 标识符要能体现实际含义
- 变量名使用小写字母
- 用户自定义的类名，大写字母开头
- 标识符多个单词组成，单词间区分 下划线或者驼峰命名

**5.复合类型**

声明语句:数据类型+变量名列表

**声明语句:基本数据类型+声明符**

声明符:命名了一个变量并指定该变量为与基本数据类型有关的某种类型


**6.引用与指针**

引用:
- 1.引用必须初始化(引用无法重新绑定对象)
- 2.引用类型初始值必须是一个对象

指针
- 1.指针是一个对象，允许赋值和拷贝
- 2.指针无须在定义时赋值

空指针，nullptr是一种特殊类型的字面值

NULL 是预处理变量


**7.与处理器头文件保护符**
```
#ifndef
#define 

#ifdef

#endif
```

头文件保护符简单，应该习惯在程序开头加上



## 第三章.字符串、向量和数组(07.28)

定义了一些丰富的抽象数据类型库

**1.头文件中不应该包含 using声明**

头文件的内容会拷贝到所引用的文件中去，头文件中有using声明，每个使用该头文件的都会有这个声明，会出现命名冲突

**2.getline()函数**

读取输入流中的内容，直到遇到换行符为止,此时的换行符也被读取进来

将读取的内容存入到string中去，将换行符去掉

输出的时候加上 std::endl换行符,刷新显示缓冲区

**3.string::size_type**

一个无符号的整型数

ispunct()  是标点符号的时候为真

字符串+字面值   可以实现
字面值+字面值   不能直接进行运算

改变字符串中的值，必须使用引用

c_str() string转向字符指针

**4.vector**

vector 是模版，必须进行实例化

() 函数构造，{} 列表初始化

解引用和成员访问

(*it).empty()  这个才可以实现    

*it.empty()

. 运算符比解引用的优先级高

**5.数组**

数组不能进行 拷贝和赋值

区别整型指针数组和 指向整数的数组

int *ip[4]    整型指针数组
int (*ip)[4]  指向含有4个整数的数组


## 第四章.表达式(07.29)

**1.重载运算符**

C++语言定义了运算符作用于内置类型和复合类型的运算对象所执行的操作

当运算符作用于类类型的运算对象时，用户可以自定义其含义，这种自定义的过程就叫重载运算符


**2.左值、右值**

c语言中的左右值定义比较简单
左值是可以放在赋值语句左侧的，而右值不可以

C++

当一个对象被用作右值的时候，用的是对象的值(内容)
          用作左值的时候，用的是对象的省份(内存中的位置)


**3.短路求值**
短路求值是一种策略

对于逻辑与、逻辑或运算符，当前仅当左侧的的对象无法确定表达式的结果时才会计算右侧的对象


递增的前置版本和后置版本

前置版本- 对象本身作为左值返回
后置版本- 对象的原始值副本作为右值返回

后置递增的优先级高于  解引用
点运算符  优先级高于  解引用

*iter++    *(iter++)

ptr->mem
(*ptr)->mem


**4.sizeof**

sizeof  返回存储对象所需的字节数

sizeof 运算符不会实际求运算对象的值

sizeof 不会把数组转换成指针来处理

**5.类型转换**

隐式类型转换

1.算术转换，整型的提升

2.数组转换成指针

3.指针转换，  0(nullptr)-> 任意类型指针 ， 任意非常量指针-> void * 
            指向任意对象的指针转换->  const void *

4.布尔类型转换

5.类类型定义的转换


显示转换

1.static_const

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast

2.const_cast

只能改变运算对象的底层const

将常量转换为非常量对象的行为，去掉const性质

3.dynamic_const

和继承及运行时类型识别一起使用



## 第五章.语句(07.29)

空块的作用等价于空语句

**1.悬垂else**

else会与离它最近，尚未匹配的的if进行匹配

要使用花括号控制执行路径

对于switch语句中  case  必须显示的告诉编译器终止程序 break

注意定义  default标签

**2.标准异常**

exception       最常见的问题
runtime_error   运行时才能检测的问题
range_error     运行是错误
overflow_error  运行时错误

logic_error     逻辑错误
invalid_argument 逻辑错误，无效参数


## 第六章.函数(07.29)

函数就是命名了的代码块

**1.函数的调用**

调用:

- 1.用实参初始化函数对应的行参
- 2.将控制权转移给被调函数，主调函数执行被暂时终止，被调函数开始执行

递归函数调用

每一次的函数调用都需要在内存栈中
分配空间；保存参数；返回地址；临时变量

往栈中压入和弹出数据都需要时间

当递归的调用层级数太多，就会超出栈的容量，导致栈溢出(严重问题)

**constexpr**

函数的形参和返回值必须是 字面值类型


分离式编译

gcc -c 生成 .o文件，可重定位目标文件  
修改后，可以进行重新编译

gcc 1.o 2.o -o     生成可执行文件
gcc -o 生成         可执行文件

**调试帮助**

预处理

assert  NDEBUG

**函数指针**

函数指针指向的是函数不是对象

对于函数的定义

只需要将函数名替换为指针就可以实现


根据调用时的参数，编译器可以自动地选定被调用的函数,从一组函数中选取最佳函数的过程成为**函数匹配**



使用引用 避免拷贝

拷贝大的类型对象或者容器对象比较低效

有的类类型以及IO类型，根本不支持拷贝操作。


## 第七章.类(07.31)

**1.类的设计**

类的设计可以现将接口函数表达出来，写出用户可以进行操作的用户使用代码

在进行接口函数的实现，

**2.this**

成员函数通过名为 this 的额外的隐式参数来访问调用它的那个对象

**const成员函数**

函数参数列表之后的const关键字，表示this是一个指向常量的指针。

这样的函数也叫常量成员函数。

默认情况，this类型是指向类类型非常量版本的 常量指针

默认情况下，不能将this绑定到一个常量对象上。

把this设置为 指向常量的指针 有助于提高函数的灵活性


类的非成员函数
函数在概念上属于类，但不定义在类中，一般与类声明(非定义)在同一个头文件内

这样用户使用接口的任何部分都只需要引用一个文件


**构造函数**

构造函数不能被声明为const

创建一个const对象，直到构造函数完成初始化过程，对象才真正获得“常量”属性。
构造函数在const对象的构造过程中可以向其写值。


如果定义了其他构造函数，那么也必须定义一个默认构造函数



友元的声明仅仅指定 访问的权限

为了使友元对类的用户可见，把友元的声明与类本身放置在同一个头文件中



mutable 可变的数据成员

即使两个类的类成员列表完全相同，也是不同的类型


一个类在创建其对象之前，该类必须被定义过，而不能是仅仅声明。
（编译器需要了解对象的存储空间，类必须定义）

**友元**

友元不具有传递性

类可以作为友元，类的成员函数也可以单独作为友元

**成员初始化顺序**

构造函数的初始值列表只能说明初始化成员的值，而不限定初始化的具体执行顺序

- 成员的初始化顺序与它们在类中定义出现的顺序一致

如果一个构造函数为所有的参数都提供了默认的实参，则它实际上也定义了默认的构造函数


**隐式类类型转换**

只允许一步一步的类类型转换

explicit 抑制构造函数定义的隐式转换
explicit 构造函数只允许在类内构造函数的声明处

explicit 关键字声明的构造函数，只能以直接初始化形式使用，不能使用拷贝赋值


**类的静态成员**

类的静态成员存在与任何对象之外

对象中不包含任何与静态数据成员有关的数据
静态成员函数不与任何对象绑定在一起，不包含this指针

static静态关键字只能在类的内部使用

一般不再类的内部初始化静态成员

静态成员类似与 全局变量，静态数据成员定义在任何函数之外，一旦被定义
存在程序的整个生命周期

**不安全类型**

不完全类型- 声明之后，定义之前

静态成员可以是不完全类型
指针成员也可以是不完全类型


## 第八章  I0库 (08.01)

IO对象无拷贝，无赋值

getline从标准输入读取整条记录

## 第九章 顺序容器 (08.01)


通常情况下 vector是最好的选择，除非你有很好的理由去选择其他容器

迭代器都是通过解引用运算符来实现访问元素操作

迭代器不需要写访问的时候，应该使用 cbegin 和 cend

注意区分内置数组类型 int[] ,和标准库 array<int,10> 

swap操作，可以交换两个相同类型容器的内容
全部元素及大小都进行来了交换

**适配器**

适配器是一个通用概念，容器、迭代器、函数都有适配器

**适配器是一种机制，能使某种事物的行为看起来像另外一个事物一样**


顺序容器:vector,list,forward_list,array,string,deque

顺序容器适配器:stack,queue,prioirty_queue

一个容器适配器接受一个已有的容器类型，使其行为看起来像一种不同的类型

queue默认基于 deque实现，priority_queue 默认基于 vector实现

每个适配器在其底层顺序容器类型上定义了一个新的接口


## 第十章 泛型算法 (08.04)

迭代器分成五类:

输入、输出、前向、双向以及随机访问迭代器

iostream 迭代器

算法是不会改变所操作序列，不会直接添加或删除元素

插入迭代器会向序列添加元素


## 第十一章 关联容器 (08.05)

使用decltype来获得一个函数指针类型时，必须加上一个* 来指出我们要使用一个给定函数类型的指针

使用make_pair来生成pair对象


key_type 此容器类型的关键字类型
mapped_type 每个关键字类型，适用于map
value_type  对于set 就是key_type ,对于map 是 pair<const key_type,mapped_type>

set的迭代器是const的

map的关键字 key_type也是const ，无法对其进行改变

不重复关键字的容器，erase的返回值总是0，1
重复关键字的容器，erase的返回值可能会大于1


c.find(k)  返回一个迭代器，指向第一个关键字为k的元素，k不在容器中，返回尾后迭代器

c.count(k) 返回关键字等于k的数量，不允许重复关键字的容器，返回值是0，1

c.lower_bound(k)   返回一个迭代器，指向一个关键字不小于k的元素

c.upper_bound(k)   返回一个迭代器，指向第一个元素大于k的元素

c.equal_range(k)  返回一个迭代器，表示关键字等于k的元素范围，


**无序容器**

使用哈希函数和关键字类型的 == 运算符

在关键字类型元素没有明显的序关系的情况下，无序容器是非常有用的

unordered_map
unordered_set

桶 bucket 

无序容器在存储组织上为一组桶，每个桶保存零个或多个元素。
无序容器使用一个哈希函数将元素映射到桶。


## 第十二章 动态内存 (08.06)

全局对象在程序启动时分配，在程序结束时销毁
局部对象，在进入其定义所在的程序块时创建，离开时销毁
局部static对象在第一次使用前分配，在程序结束时销毁


动态分配的对象的生存期与其在哪里创建无关，只有当显式的释放，这些对象才销毁


**存储分布**

1.静态内存--- 局部static对象，类static数据成员，定义在任何函数之外的变量

2.栈内存  -- 定义在函数内的非static对象

3.堆      -- 存储动态分配

c++中动态内存管理通过一对运算符  new + delete

**shared_ptr是一个类**智能指针类。

最安全使用和动态分配内存是 调用一个make_shared<T>的标准库函数

智能指针类能记录多少个shared_ptr指向相同的对象，并能在恰当的时候自动释放对象

**shared_ptr的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0，shrard_ptr的析构函数会销毁对象，并释放其所占用的内存**



**直接管理内存**

自由空间分配的内存是无名的，new无法为其分配的对象命名，而是返回一个指向该对象的指针

类似于其他const对象，一个动态分配的const对象必须进行初始化


delete 接受一个指针

1.销毁给定的指针指向的对象
2.释放对应的内存


内置指针(非智能指针)管理的动态内存被显示释放前一直都会存在

delete 指针之后，指针失效，但保存着已经释放了的动态内存地址
指针变成**空悬指针** （dangling pointer）

这就是为什么要在 delete p 之后 p=nullptr ，将nullptr 赋予指针

防止空悬指针的出现


**接受指针参数的智能指针构造函数是explicit**

不能将内置指针隐式转换成为一个智能指针

explicit 声明构造函数只能一直接初始化的形式使用


**智能指针与异常**

异常处理程序能让程序在发生异常后令程序流程继续，要确保在异常后，资源能被正确的释放

一个保证资源被释放的方法就是使用智能指针


**unique_ptr**

不支持普通的赋值和拷贝工作

但是可以拷贝一个将要被销毁的 unique_ptr

例如，从函数返回一个unique_ptr,返回一个局部对象的拷贝.这些对象编译器都知道将要被销毁


**weak_ptr**

不控制所指对象生存期的智能指针，指向一个shared_ptr管理的对象

将weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数


释放动态数组  - delete []pa      pa指向一个动态分配的数组或空
             
              delete p         p指向一个动态分配对象或空

new -    内存分配+对象构造
delete - 对象析构+内存释放


**allocator**

分配未构造(unconstructed)的内存




**sort函数中cmp**
sort中的比较函数compare要声明为静态成员函数或全局函数，不能作为普通成员函数，否则会报错。 因为：非静态成员函数是依赖于具体对象的，而std::sort这类函数是全局的，因此无法在sort中调用非静态成员函数。静态成员函数或者全局函数是不依赖于具体对象的, 可以独立访问，无须创建任何对象实例就可以访问。同时静态成员函数不可以调用类的非静态成员。




## 第十三章 拷贝控制 (08.07)

一个类定义五种成员函数来控制 类的对象拷贝、移动、赋值和销毁

拷贝构造函数

拷贝赋值运算符

移动构造函数

移动赋值运算符

析构函数


实现拷贝控制最难的地方就是首先要认识**什么时候需要定义这些操作**

**拷贝构造函数**

直接初始化 - 编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数
拷贝初始化 - 要求编译器将**右侧运算对象**拷贝到正在创建的对象中，如果需要可能要进行类型转换


拷贝初始化 - 拷贝构造函数或 移动构造函数来实现


这句话，多念几遍

拷贝构造函数是被用来初始化**非引用类类型参数**,这也解释了为什么拷贝构造函数自己的参数必须是引用类型。

如果参数不是引用类型，则调用永远不会成功。

为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，我们又需要拷贝函数,进入死循环


**拷贝赋值运算符**

重载运算符本质上就是函数

赋值运算符就是一个名为operator=的函数


**三/五法则**

1.如果一个类需要析构函数，那么肯定也需要一个拷贝构造函数和拷贝赋值运算符



**对象移动**

std::move

1.在重新分配内存的时候，从旧内存将元素拷贝到新内存是没有必要的，移动可以更好的实现

2.I/O类，unique_ptr类，这些类都包含不能被共享的资源(指针,I/O缓冲),这些类型不能拷贝，但是可以移动


右值引用

&& 来获得右值引用

右值引用只能绑定到一个将要销毁的对象，可以将一个右值引用的资源,移动到另一个对象

变量表达式都是左值，变量是持久的，直到离开作用域才会被销毁


std::move() 可将一个左值变成右值





#### const && static

| |const |static|
|--|--|--|
|普通变量|变量不可以被修改| 修改存储区域和生命周期,main函数运行前分配空间|
|普通函数|null|函数的作用范围，仅在该函数的文件内才能使用|
|指针|分为指向常量的指针，指针常量|null|
|成员函数|该成员函数内不能修改成员变量|不需要生成对象就可以访问函数|
|成员变量|null|所有的对象只保存一个该变量|

顶层const top-level const:表示指针就是一个常量
底层const low-level const:指针所指的对象是一个常量

#### this pointer this指针
>this指针是一个隐藏的特殊指针，指向成员函数操作的对象
>this是一个常量指针

#### inline函数
> 简单的概括就是宏定义，调用内联函数的调用点上进行展开
```cpp
// 原函数
const string &shorterString(const string &s1,const string &s2)
{
    return s1.size()<=s2.size() ? s1:s2;
}
// 声明为内联函数inline
inline const string &shorterString(const string &s1,const string &s2)
{
    return s1.size()<=s2.size() ? s1:s2;
}
```
>调用函数
```cpp
cout<<shorterString(s1,s2)<<endl;
```
>内联函数在调用点进行展开
```cpp
cout<<(s1.size()<=s2.size() ? s1:s2)<<endl;
```

>内联函数的一些性质
>> 0.不用执行进入函数的步骤，直接执行函数体
>> 
>> 1.不能包含循环、递归、switch等复杂操作
>> 
>> 2.在类声明中定义的函数，除了虚函数其他函数都会自动隐式的当成内联函数


#### assert()
>断言不是函数，是宏
>通过NDEBUG来关闭 assert
> expr为假，assert输出信息并终止程序
> expr为真，assert则什么也不做
> 
```cpp
#define NDEBUG
#include <assert.h>
// include<cassert>
assert(expr);
```

#### struct & class
>struct 适合作为一个**数据结构的实现体**
>class 适合看成一个**对象的实现体**

|区别|struct|class|
|---|---|----|
|默认访问控制|public|private|


#### c++类内定义 引用数据成员

可以定义引用数据成员，必须通过成员初始化列表初始化








