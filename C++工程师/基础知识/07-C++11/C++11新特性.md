C++11
===

#### 简单描述一下C++11的所有新特性
- auto 关键字，可以自动推导出类型。但不能用于函数参数传递和数组推导
- nullptr nullptr 是一组特殊类型的字面值，可以转化为其他指针类型，NULL 定义为0，在重载的时候会出问题
- 智能指针
- 初始化列表，初始化列表来对列进行初始化
- 右值引用，节省资源，提高效率
- atomic原子操作，多资源线程互斥操作
- stl 容器 array 和 tuple

#### C++11可变参数模版
**可变参数模版** 对参数进行来高度的泛化，可以表示**任意数目、任意类型**的参数
- 语法类型是在 typename 或者 class 后面加上...
- C++11采用递归的方式展开参数包，获得可变参数的每个值
```cpp
#include<iostream>
using namespace std;

template<class ...T>
void func(T ... args){
    cout<<"nums is"<< sizeof...(args)<< endl;
}

func();  // args 不包含任何参数
func(1); // args 包含int类型的参数
func(1,2.0);  //args 包含int，一个double类型的参数
// T 模板参数包，args函数参数包

// 最终的递归函数
void print(){
    cout<<"empty"<<endl;
}

// 展开函数
template void print(T head,Args ... args)
{
    cout<< head <<",";
    print(args...);
}
int main(){
    print(1,2,3,4);
    return 0;
}
```

#### 右值引用

右值
- 右值就是无法进行取地址，没有名字的值

右值的分类:
- 将亡值  具有转移语义的对象，返回右值引用T&&的函数返回值
- 纯右值  一些临时变量和不和对象关联的的值

基于右值引用 可以实现转移语义和完美转发新特性

转移语义:
- 对于一个包含指针变量的类，编译器默认的拷贝都是潜拷贝，所有需要实现深拷贝的拷贝构造函数，
为指针分配新的内存，进行内容拷贝，防止出现悬挂指针的问题。




