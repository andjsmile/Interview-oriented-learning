### 基础知识02

#### 虚函数&析构函数

Q1:为什么析构函数必须是虚函数

将可能被继承为父类的析构函数设置为虚析构函数。
这样保证了，当我们new一个子类，使用基类指针指向子类对象，在释放基类指针时可以释放掉子类的空间，防止内存泄漏。

Q2:为什么析构函数默认不是虚函数

默认的析构函数不是虚函数，因为虚函数的设置需要占用内存(设置虚函数表和虚函数指针)。对于不会被继承的类来说，析构函数如果设置为虚函数就会浪费内存。
C++默认析构函数不是虚函数，只有称为父类父类时将析构函数设置为虚函数

Q3：简单的说说你对析构函数的了解

析构函数与类名相同，加上～符号，与构造函数相互对应。对象的函数调用完毕，系统会自动执行析构函数
类中有指针，动态调用类内存，析构函数在销毁类之前，释放申请的内存空间，避免内存泄漏。

很重要的知识点: 类中的析构顺序
1.派生类本身的析构函数 2.对象成员析构函数 3.基类析构函数



#### 函数指针

函数指针的定义

指针变量指向一个具体的函数
```cpp
// use a example to explain

// define a string length compare function
bool lengthCompare(const string & ,const string &);  

// use pointer instead the function name get  function pointer

bool (*fp) (const string &,const string &);

// error !!!!
// it's fp function ,return_value= bool*
bool *fp (const string &,const string &); 
```

程序编译后，每个程序都有入口地址，入口地址就是函数指针指向的地址
有了函数指针，可以直接使用指针变量调用函数

```cpp
// specific example
char* fun(char* p){ }    // fun fuction
char* (*pf)(char* p);    // 函数指针pf
pf=fun;                  // 函数指针pf指向函数fun
pf(p);                   // 通过指针调用函数fun
```

#### fork 函数
Q:请说一下你对fork函数的了解

fork()函数不在C的函数库中,调用这个函数是依赖编译器和操作系统的
```cpp
#include <unistd.h>
// 所定义的接口通常都是大量针对系统调用的封装 wrapper functions
// 如 fork、pipe 以及各种 I/O 原语（read、write、close 等等）。
```

fork and exec

成功调用fork会产生一个新的进程，和调用fork函数的进程一摸一样。两个进程都继续运行。
成功的fork()调用 return 0；父进程中fork()返回子进程的pid，如果出现错误，return一个负值。

#### 静态函数与虚函数的区别

静态函数在编译的时候已经确定运行时机
虚函数在运行的时候动态绑定，虚函数使用了虚函数表，调用的时候会增加一次内存开销。

#### 重载和覆盖
Q:阿里巴巴面试官的问题
重载:在同一作用域中，相同的函数名，具有不同的形参列表。返回类型没有要求。
覆盖:派生类对基类虚函数的重新定义，重新定义了虚函数，override 重写


#### strcpy 和 strlen 函数

strcpy() 是定义在 cstring 头文件中的字符串拷贝函数
char* strcpy(char* dest,const char* src); 
拷贝source中字符串直到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞
可以使用  strncpy() 防止拷贝越界
char* strncpy(char* dest,const char* src,std::size_t count);

strlen() 是字符串长度  -The length of the null-terminated string str.
std::size_t strlen(const char* str);


#### 虚函数和多态
Q:说说你对虚函数和多态的了解

A1:
虚函数 函数名前面加上virtual的类成员函数，派生类可以继承，并对函数进行重写(覆盖)。

虚函数拓展知识点:

在有虚函数的类中、类的最开始是虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数地址。

当子类继承父类的时候，也会继承虚函数表。子类重写父类中的虚函数，会将继承的虚函数表中的地址替换为重新写的函数地址

使用虚函数会增加内存开销，降低效率

多态，在对象调用函数的时候，进行动态绑定，只有到函数运行的时候，才知道运行那个版本

A2:标准的回答
多态分为静态多态 和 动态多态
静态多态主要是重载，在编译的时候已经确定
动态多态是虚函数机制实现的，虚函数运行时动态绑定，虚函数用了虚函数表机制，调用时会增加内存开销。

#### ++i,i++的具体实现
前递增，后递增的区别 
```cpp
// ++i 返回的是递增后的值
int& int:operator++()   // 注意返回值的类型，一个引用可以改变值
{
    *this +=1;
    return *this;
}

// i++ 的实现

const int int::operator++()
{
    int oldValue=*this;
    ++(*this);          // 指针进行递增
    return oldValue;
}
```

#### 函数可以在main函数前运行
before main function run .
见运行函数


#### 智能指针shared_ptr的实现
理解智能指针，核心要理解引用计数、什么时候销毁底层指针、构造赋值函数时指针计数的变化
析构时候，底层指针引用计数为0的时候才能真正释放底层指针的内存


#### 常量的定义及实现
常量就是一个 top-level const 加上对象类型
常量定义必须初始化

局部对象-常量存放在栈区
全局对象-常量存放在全局/静态存储区
字面值常量-常量存放在常量存储区

#### const修饰成员函数的目的
const 修饰的成员函数表示，函数调用不会对对象作出改变

const对象和普通对象都可以调用该函数

一般情况下，如果确认不会对对象进行更改，最好都加上const








