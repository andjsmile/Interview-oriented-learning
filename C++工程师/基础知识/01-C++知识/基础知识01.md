### 基础知识01

基础知识是指在面试过程中常见的面试官觉得常见常问的基础知识

#### static 

static 全局变量只能在本文件使用，其他文件中使用 extern也是不行的。
static 的局部变量定义在数据段上，其他变量定义在分配在栈上，会因为函数栈帧的释放而被释放掉。
static 类的成员变量和成员函数，变量/函数就没有了 this指针，必须通过类名才能访问

1.1 全局静态变量(普通变量)
    在全局变量前加上 static 会变成全局静态变量。系统会进行默认初始化(0)，作用于整个文件中，从定义到文件结尾。 
    在内存的静态存储区，在程序的运行过程中一直存在

1.2 局部静态变量(普通变量)
    在局部变量前加上 static 变成局部静态变量。系统会默认的初始化(0)，作用域为局部，就是函数或者语句块结束的时候。
    特点，就是函数(语句块)运行结束后，静态变量仍存在没有销毁,驻留在内存中，不可以访问 。下次进行访问的时候值不变

2.静态函数(普通函数)
    在静态函数的返回类型前加上 static 关键字变成静态函数。
    只在声明的文件可见，不能被其他文件使用，函数只可以在本cpp中使用，不会同其他cpp的同名函数引起冲突。

3.类静态成员(成员变量)
    类中，静态成员实现数据在多个函数共享。静态成员是类中所有对象的共享成员。静态成员只存储一处，所有成员使用

4.类静态函数(成员函数)
    类的静态成员，都不是对象成员。对静态成员的引用不需要对象名。
    但是静态函数只能访问静态成员，不能直接引用类中的非静态成员(静态成员函数要引用非静态成员，可以通过对象来引用)

#### 关键字 static另一种解释

static 有三大作用
- 1.隐藏
程序编译多个文件时，未加上static前缀的**全局变量**和**函数**都是具有全局可见性的

不同的文件中定义同名函数和同名变量，不必担心命名的冲突

- 2.保证变量内容的持久

静态存储区：全局变量，static变量(可以控制范围的局部隐藏)

- 3.默认初始化为 0

在静态存储区，内存中所有的字节默认为0x00

这样可以在变量定义的时候赋值，减少程序的工作量

- 4.类相关

类的静态成员可以实现多个对象之间数据的共享，并且不会破会隐藏规则，保证安全性

静态成员是类所有对象的共享成员，静态数据只存储一处，供所有对象使用

类的静态函数，不能引用类中的非静态成员

#### C++/C的区别
2019年阿里巴巴暑期实习生-电话摸底面试

Q:具体谈一谈 C++/C的区别
A:C++是面对对象的语言，C是面向过程的语言
Q:这个就是定义的上的区别，具体细化的谈一下
A:(内心what?，这个咋说)不是很清楚？

Q:那你说说C++中 重载和覆盖的区别
A:(忘了！！！挂了，绝壁挂了) 嘿嘿，忘记了！

C++/C的主要区别

1.设计思想上 ，C++是面对对象的语言，C是面向过程的结构化语言
2.语法上， C++有重载、多态、继承三种特性；C++比C多一些类型安全功能(强制类型转换)
3.C++支持范式编程(模版类、函数模版)
4.C++是C语言的继承，不仅可以进行过程化的程序设计，还可以进行抽象数据类型为特点的基于对象的程序设计，
  还可以进行以继承和多态为特点的面向对象的程序设计。
  


#### C++中四种cast转换

强制类型转换运算符

[各个类型特点及应用场合](https://www.cnblogs.com/mjiang2017/p/9358032.html)

1.static_cast
    stataic_cast<type-id> (expression)
    no run-time type check ,conversation are not always safe 有时候转换不安全
    用于非多态类型的转换(各种隐式转换)，通常用于执行转换数值类型数据
    可以向上转换，子类转换为父类  ;向下转换不安全               ----- 向上转换是一种隐式转换

特点:静态转换，编译期间进行处理
应用:主要用于C++内置类型之间的转化，没有运行时类型检测来保证转换的安全性

2.dynamic_cast
    dynamic_cast<type-id> (expression)
    用于动态类型转换，必须是含有虚函数的类。用于类层次间的向上或向下转化
    转换指针和引用。对于不明确的转换 return nullptr 但是不会引发异常

应用:主要用于上下行之间的转换，也可以用于类之间的交叉转换。上行转换时和static_cast效果一样，
下行转换时，具有检测功能，比static_cast更安全

3.const_cast
    const_cast<type-id> (expression)
    remove the const,volatile,and _unaligned attributes from a class.
    用于删除cosnt,volatile,_unaligned属性，将const 转换成非 const     const int ->int

特点:去常转换，编译期间运行
应用场合:将一个非const的转换为const 或者verse

4.reinterpret_cast
    reinterpret_cast<type-id> (expression)
    Allows any pointer to be converted into any other pointer type.  指针对指针的转换
    Also allows any integral type to be converted into any pointer type and vice versa 整形指针类型相互转换
    类型使用不太安全，一般不使用(use other cast)

特点： 重解释类型转换 
应用场合：它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式

其他cast
bad_cast
强制转化为引用类型失败
dynamic_cast 运算符引发 bad_cast 异常

Q:为什么不能使用C的强制转换
A:C的强制转换不够明确，不能进行错误检查，容易出现错误


#### C++/C中 指针和引用的区别

1.指针有自己的空间。引用只是一个别名
2.sizeof(指针)，指针的大小为4。 引用取sizeof 返回的被引用对象的大小
3.指针可以被初始化为NULL。引用必须被初始化，且必须是一个已有对象的引用
4.作为参数传递的时候，指针需要被解引用才可以对对象进行操作。直接对引用的修改，对改变引用所指向的对象
5.指针可以const  const 指针。  引用不能被const 
6.指针在使用中可以指向其他对象。  引用只能是一个对象的引用
7.指针可以用多级指针(**p)
8.指针和引用使用++运算符的意义不一样
9.返回动态内存分配的对象或内存，必须使用指针。引用可能引起内存泄漏


#### 判断一点P是不是在三角形ABC中
方法:面积法

if(Sabc=Sabp+Sapc+Sbcp )
    p in Triangle inside;
if(p in ab || p in bc || p in ac)
    p in Triangle edge;

代码实现- ./TriangleArea.cpp

#### C++四个智能指针

#####  简单聊聊 智能指针

1.智能指针管理堆上分配的内存，智能指针将指针封装为一个栈对象。当栈结束生命周期，会在析构函数中释放申请的内存，放置内存泄漏
2.常用的shared_ptr指针采用计数的方法，记录当前内存被多少智能指针引用。引用计数的内存在堆上分配
3.shared_ptr不能直接有指针进行赋值，因为shared_ptr 是一个类。可以使用make_shared将指针转换成智能指针，使用get函数提取普通指针。

智能指针都在头文件  
```cpp
#include<memory> 
```
Q:为什么要使用智能指针？
A:智能指针的作用是管理一个指针，如果申请的空间在函数结束时忘记释放、会造成内存泄漏。
  智能指针就是一个类，当超出类的作用域，类会自动调用析构函数，析构函数释放资源。实现函数结束是自动释放内存空间。


1.shared_ptr
    shared_ptr 允许多个指针指向同一个对象
    在最后一个引用被销毁的时候释放，利用计树(use_count())来反应被几个共享

2.unique_ptr
    unique_ptr 独占所指的对象
    实现独占式的严格拥有，避免资源泄漏 替代 auto_ptr;
    使用标准库 std::move() 可将 一个unique_ptr赋值给另一个


3.weak_ptr
    weak_ptr 弱引用，指向shared_ptr 所管理的对象
    一个不可控制对象生命周期的智能指针
    用来解决 shared_ptr相互引用时死锁的问题。如果两个shared_ptr相互引用，那么引用计数不可能下降为0

4.auto_ptr
    已经被弃用

smartpointer.cpp

#### 位运算

Q:如何判断一个数是2的倍数，如何求得一个数中1的个数，编程实现

if(x%2==0) 
if(x &0x0001== 0)


#### 指针和数组的区别
1.指针是保存数组的地址，数组是保存数据
2.指针访问数据是间接访问，数组是直接访问
3.指针用于动态数据结构，数组用于固定数目且数据类型相同
4.malloc ,free 释放分配内存，隐式的分配和删除
5.指向匿名数据，操作匿名函数，自身即是数据名


append  野指针 wildpointer

野指针就是指向一个已删除的对象，未申请访问受限内存区域的指针


#### const

成员函数不改变类的数据成员
可以在函数定义的后面加上 const
函数后面加上const的好处:

1.可以提高程序的可读性
2.提高程序的可靠性 (已经定义为const的成员函数，不能对其数据成员进行修改操作，
                  一旦企图修改数据成员的值编译器会按照错误处理)

表示成员函数隐含传入的this指针为const指针，决定了该成员函数中，任意修改它所在类的成员操作都是不允许的

加了从const的成员函数可以被非const对象和从非const对象调用
不加const的成员函数只能被非const对象调用


### decltype

简化返回类型的定义

