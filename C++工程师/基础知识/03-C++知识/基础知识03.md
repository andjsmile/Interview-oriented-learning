#### 隐式的类型转换
何时发生隐式的类型转换:
1.类型小的整型值 提升为较大的整型值
2.低精度的变量给高精度的变量赋值会发生隐式类型转换
3.条件中，非布尔值转换成布尔类型
4.算术运算或者关系运算对象有多种类型。需要转换成一种类型
5.函数调用的时候也会发生类型转换
6.对于单个构造函数

常见的有:
整型提升
数组转换成指针
转换成布尔类型

#### 类型转换
1.reinterpret_cast - 完成任意类型转换，转换结果不确定
2.dynamic_cast   - 存在虚函数的父子关系的强制类型转换
3.static_cast  -  各种隐式转换
4.const_cast  - 使用const_cast来去除const引用对象的const

#### C++函数栈空间最大值
函数栈是有默认值的

默认是1M,大小可以进行改变

关于C的内存分配
1.程序段-程序代码在内存中的映射
2.初始化过的数据-程序运行值已经对变量进行初始化
3.未初始化的数据-程序未对变量初始化的数据
4.栈 stack- 局部、临时变量,在程序块开始时自动分配，结束时自动释放
5.堆 heap- 存储动态内存分配，手动分配、释放
6.文字常量区-常量字符串
```c
// 程序来加深理解
int a=0;              // 全局初始化
char *p1;             // 全局未初始化
main()
{
    int b;             // 栈
    char s[]="abc";    // 栈
    char *p2;          // 栈
    char *p3="123456"; // 123456\0在常量区 p3在栈上
    static int c=0;    // 全局静态初始化区
    p1=(char*)malloc(10);
    p2=(char*)malloc(20);   //在堆区进行分配
    strcpy(p1,"123456");
}
```

#### extern C
c++调用c函数需要 extern C,因为c语言没有函数重载。
实现c++代码调用c代码

#### C语言如何进行函数调用，参数的压栈顺序

每一个函数调用时，都会分配函数栈，在栈内进行函数执行过程。
调用前，先将返回地址进行压栈，当前函数的esp指针进行压栈   esp:extend stack pointer 栈指针寄存器

参数的压栈顺序是  从右到左

#### new/delete  malloc/free的区别
new/delete 是C++的关键字
malloc/free 是C的库函数

#### 所了解的RTTI
run-time type identification 运行时类型识别
由两个运算符实现
typeid 运算符，返回表达式类型
dynamic_cast，将基类指针或者引用安全转换成为派生类的指针或引用

#### C++如何处理返回值
？？？
生成一个临时变量，并将其引用作为函数参数传入函数

#### c++中拷贝赋值函数的形参能否进行值传递
！！！不可以
调用拷贝构造函数的时候，首先 实参要传递给形参，这个传递又要拷贝构造函数，会一直循环下去

#### select 
??? 完全没见过
select在使用前，先将需要监控的描述符对应的bit位置1，然后将其传给select,当有任何一个事件发生时，select将会返回所有的描述符，需要在应用程序自己遍历去检查哪个描述符上有事件发生，效率很低，并且其不断在内核态和用户态进行描述符的拷贝，开销很大

#### fork，wait，exec函数
fork函数 -父进程产生子进程使用fork拷贝出来一个父进程的副本，exec函数可以加载一个elf文件替换父进程，父进程和子进程可以运行不同的程序。
fork从父进程返回子进程的pid，从子进程返回0
调用wait父进程将会发生阻塞，直到有子进程状态改变，执行成功返回0，错误返回-1
exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1


#### 静态函数和虚函数
静态函数在编译的时候已经确定运行时机
虚函数在运行时进行动态绑定-虚函数因为用了虚函数表机制，在调用时会增加一次内存开销


#### 再谈static关键字
1.加上static静态关键字的全局变量只能在本文件中使用，跨文件使用 extern 也不能继续使用了-可以利用这个性质来防止成员命名冲突
2.静态局部变量存储在数据段上
  普通局部变量存储在栈上，会因为函数栈帧的释放而被释放掉

3.类成员变量、成员函数 加上static关键字，变量、函数没有this指针，必须通过类名才能访问

#### strcpy & strlen
1.strcpy的原型函数
char* strcpy(char* dest,const char* src); //字符串拷贝 strncpy

2.strlen原型函数
std::size_t strlen(const char* str)
返回不包含\0（null character）的字符个数 


#### bitset 

类似于数组的构成 bitset 是一个类模版


