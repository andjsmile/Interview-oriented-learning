#### 1.C++源文件从文本到可执行文件经历的过程
一般情况下是四个步骤从文本到可执行文件

1.Pre-processer 预处理阶段
对源代码文件中文件包含关系(头文件)，预编译语句(宏定义)进行分析替换，生成编译文件     hello.c-hello.i

2.Compiler      编译阶段
将处理后的预编译文件转换成特定的汇编代码，生成汇编文件                           hello.i-hello.s

3.Assembler     汇编阶段
将编译阶段生成的汇编文件转换成机器码，生成可重定位目标文件                        hello.s-hello.o

4.Linker        链接阶段
将多个目标文件及所需要的库链接成最终的可执行目标文件                             hello.o+pritnf.o -  hello    exe


#### 2.include 头文件的顺序 双引号“”及 尖括号<> 的区别

1.include头文件的顺序
文件 a.h 中声明一个在文件 b.h中定义的变量 ，而不引用b.h
文件 a.c 中引用b.h，并且要先引用b.h  后引用 a.h 否则会出现回报变量类型未声明错误

2.谈一谈双引号"" 和尖括号<>的区别
编译器预处理阶段 查找头文件的路径不一样

使用""头文件的查找路径:
1.当前头文件目录
2.编译器设置的头文件路径
3.系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

使用<>头文件的查找路径:
1.编译器设置的头问价路径
2.系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

#### 3.Malloc系统原理 brk，mmap系统调用的作用是什么
malloc函数用于动态分配内存
为了减少内存碎片和系统调用的开销，malloc采用内存池的方式，先申请大块内存作为堆区，将堆区分成多个内存块，以块作为内存管理的基本单位
当用户申请内存时，之前堆区分配一个合适的空闲块

Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。

malloc在申请内存的时候，一般会通过brk或mmap系统调用进行申请。
当申请的内存小于 128k，会使用系统函数brk在堆区中分配         brk 是堆顶指针
当申请的内存大于 128k, 会使用系统函数mmap在映射区进行分配

malloc 申请内存的时候并不会初始化内存,
calloc 会将内存初始化为0
realloc 可以改变之前分配内存块的大小
mmap & munmap 是用来删除虚拟内存区域
mmap 和 munmap是一组 can allocate or deallocate heap memory explicitly 也可以使用 sbrk

#### 4.C++内存管理
可以参考c的内存
虚拟内存分为:代码段+数据段+BSS段+堆区+文件映射区+栈区

代码段:包含只读存储区和文本区 .text 只读存储区保存字符串常量，文本存储区保存机器码
数据段:initialized data    .data 存储已经初始化的全局变量和静态变量
BSS段: uninitialized data .bss  未初始化的全局变量和静态变量，所有被初始化为0的全局变量和静态变量
堆区: Heap  调用 new/malloc 分配内存，调用 delete/free 释放内存      brk指针指向堆顶
映射区:共享库的内存映射区域         存储动态库链接以及调用mmap函数进行的文件映射
栈区:使用栈空间存储函数的返回地址，参数，局部变量，返回值                %rsp指针

#### 5.C++内存分配

内存分配
32bit CPU可以寻址 4G 的线性空间
每个进程都有独立的4G逻辑地址  0～3G是用户空间，3～4G是内核空间
不同进程相同的逻辑地址会映射到不同的物理地址中

逻辑地址的划分:
3G的用户空间，1G的内核空间

静态区域:
代码段  text segment :包括只读存储区和文本区，只读存储区存放字符串常量，文本区存放机器码
数据段  data segment :存放已经初始化的全局变量的静态变量
BSS段   bss segment :存放未初始化的全局变量、静态变量 或者初始化为0的全局变量、静态变量
                     对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

动态区域:
堆区: heap segment : 当进程没有调用函数 malloc时 是没有堆段的，只有调用malloc才分配一个堆，程序运行过程中可以动态的增加堆大小
                    通过移动break指针，从低地址向高地址增长。分配小内存时使用该区域
                    堆的起始地址由 mm_struct结构体中的 start_brk标识，结束地址由brk标识
映射区:memory-mapped region for shared libraries segment:
                     存储动态链接库等文件映射、申请大内存 malloc 调用mmap函数

栈区:  stack segment:使用栈空间存储函数的返回地址、参数、局部变量、返回值
                    高地址向低地址增长。在创建进程中会有一个最大栈大小，linux可以通过ulimit命令指定

#### 6.什么是内存泄漏
内存泄漏 memory leak

内存泄漏是由于疏忽或者错误导致的程序未能正确的释放不再使用内存的情况
内存泄漏并不是物理上的内存消失，分配某段内存后，由于设计错误失去了区该段内存的控制，造成了内存的浪费

内存泄漏的分类:
- 1. heap leak 堆内存泄漏
是指内存在运行中需要从 malloc new realloc 从堆中分配一块内存，内存使用后必须有相应的free和delete将内存进行删除
如果程序没有释放

- 2. resource leak  系统资源泄漏
是指系统分配的资源bitmap，handle ,SOCKET 没有使用相应的函数释放掉，导致系统资源的浪费，系统能效降低，系统运行不稳定

- 3. 没有将基类析构函数定义为虚函数。当基类对象指向子类对象时，基类的析构函数不是 virtual，那么子类的析构函数将不会被调用
子类资源没有正确的释放，因此造成内存泄漏。



#### 7.如何判断内存泄漏
内存泄漏的原因是什么？
内存泄漏是因为调用了malloc/new内存申请操作，但是缺少了相对应的free/delete
为了判断内存是否泄漏，一方面可以使用内存泄漏检测工具 Valgrind
                  另一方面，添加内存申请和释放的统计功能，内存申请和释放是否一致，来判断内存是否泄漏

#### 8.为什么会出现 段错误

段错误一般发生在非法访问内存地址的时候，具体可以分为一下几种情况
1.使用野指针  wlidpointer
2.试图修改字符串常量的内容


